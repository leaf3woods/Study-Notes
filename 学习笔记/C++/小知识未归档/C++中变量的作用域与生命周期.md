## C++中变量的作用域与生命周期

  今天在论坛上看到有朋友发帖问道：既然静态全局变量与全局变量都存储在全局数据区，为什么作用域却不一样呢？也许答案非常简单：C++就是这么规定的，静态全局变量与全局变量的唯一区别就是作用域不同。 
 对一个C++变量来说，有两个属性非常重要：作用域和生命周期，它们从两个不同的维度描述了一个变量--时间和空间。顾名思义，作用域就是一个变量可以被引用的范围，如：全局作用域、文件作用域、局部作用域；而生命周期就是这个变量可以被引用的时间段。不同生命周期的变量，在程序内存中的分布位置是不一样的。一个程序的内存分为代码区、全局数据区、堆区、栈区，不同的内存区域，对应不同的生命周期。 
 有很多方法来指定一个变量的作用域和生命周期。最常见的，如：{ }、static修饰符等。下面按照作用域与生命周期来对变量做一个分类： 

##### 全局变量 

- 作用域：全局作用域（全局变量只需在一个源文件中定义，就可以作用于所有的源文件。）
- 生命周期：程序运行期一直存在引用方法：其他文件中要使用必须用extern 关键字声明要引用的全局变量。
- 内存分布：全局数据区注意：如果在两个文件中都定义了相同名字的全局变量，连接出错：变量重定义例子： 

```c++
//defime.cpp
int g_iValue = 1;

//main.cpp
extern int g_iValue;

int main()
{
    cout << g_iValue;
    return 0;
}  
```

##### 全局静态变量 

- 作用域：文件作用域（只在被定义的文件中可见。）
  生命周期：程序运行期一直存在
  内存分布：全局数据区
  定义方法：static关键字，const 关键字

   注意：只要文件不互相包含，在两个不同的文件中是可以定义完全相同的两个静态变量的，它们是两个完全不同的变量  

   例子：

```c++
const int iValue_1;
static const int iValue_2;
static int iValue_3;

int main()
{
    return 0;
}  
```

##### 静态局部变量 

- 
     作用域：局部作用域（只在局部作用域中可见）   

-    生命周期：程序运行期一直存在  

-    内存分布：全局数据区

-    定义方法：局部作用域用中用static定义   

-    注意：只被初始化一次，多线程中需加锁保护    


   例子：

```c++
void function()
{
    static int iREFCounter = 0;
}  
```

##### 局部变量 

- 
     作用域：局部作用域（只在局部作用域中可见）    

-    生命周期：程序运行出局部作用域即被销毁   

-    内存分布：栈区  

-    注意：auto指示符标示   
-   还有一点要说明，掌握static关键字的使用很关键。以下是引用别人的一些经验之谈： 

Tips: 

1. 
      若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；    

2.    若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；    

3.    设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；  

4.    如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带“内部存储器”功能的的函数)    

5.    函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。 


